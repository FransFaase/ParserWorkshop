<HTML><HEAD>
<SCRIPT SRC="jquery-3.6.0.min.js"></SCRIPT>
<SCRIPT SRC="d3.v3.min.js"></SCRIPT>
<SCRIPT SRC="d3Tree.js"></SCRIPT>
<link rel="stylesheet" type="text/css" href="tree-viewer.css">
<SCRIPT>
<!--

function int_tree(i)
{
	return { type:"int", value:i, print:function() { return "int:"+this.value; }, transf:function() { return { name:("int:" + this.value), children:[]} } }
}

function double_tree(d)
{
	return { type:"double", value:d, print:function() { return "double:"+this.value; }, transf:function() { return { name:("double:" + this.value), children:[]} } }
}

function ident_tree(n)
{
	return { type:"ident", value:n, print:function() { return "ident:"+this.value; }, transf:function() { return { name:("ident:" + this.value), children:[]} } }
}

function string_tree(s)
{
	return { type:"string", value:s, print:function() { return "string:\""+this.value+"\""; }, transf:function() { return { name:("string:\"" + this.value + "\""), children:[]} } }
}

function char_tree(s)
{
	return { type:"char", value:s, print:function() { return "char:'"+this.value+"'"; }, transf:function() { return { name:("char:'" + this.value + "'"), children:[]} } }
}

function _tl_tree(t, n, c)
{
	return { type:t, name:n, children:c,
		print:function()
		{
			var s = this.type == "tree" ? this.name + "(" : "(";
			for (var i = 0; i < this.children.length; i++)
			{
				if (i > 0)
					s += ","
				if (this.children[i] == undefined)
					s += "<NULL>"
				else
					s += this.children[i].print()
			}
			return s + ")"
		},
		transf:function()
		{
			if (this.type == "list" && this.children.length == 1)
				return this.children[0].transf()
			var children = this.children.length == 1 && this.children[0] != undefined && this.children[0].type == "list" ? this.children[0].children : this.children
			var childs = []
			for (var i = 0; i < children.length; i++)
				if (children[i] == undefined)
					childs.push({name:"<NULL>", children:[]})
				else
					childs.push(children[i].transf())
			return { name:(this.type == "tree" ? this.name : "LIST"), children:childs }
		}
	}
}

function tree_tree(n, c=[]) { return _tl_tree("tree", n, c) }
function list_tree(c=[]) { return _tl_tree("list", undefined, c) }

function add_child(t, c)
{
	t.children.push(c)
}


var RK_TERM = 1
var RK_NT = 2
var RK_LIT = 3
var RK_GROUP = 4

function ident_start_char(ch) { return (65 <= ch && ch <= 90) || (97 <= ch && ch <= 122) || ch == 95; }

function print_rule_options(rule)
{
	var s = ""
	if (rule.chain_sym != undefined)
		s += " CHAIN '"+rule.chain_sym+"'"
	else if (rule.sequential)
		s += " SEQ"
	if (rule.optional)
		s += " OPT"
	if (rule.next != undefined)
		s += rule.next.print()
	return s
}

function make_rule(children, nr, grammar, in_nt)
{
	if (nr >= children.length) return undefined
	var rule = children[nr]

	if (rule == undefined)
	{
		return undefined;
	}
		
	var result = { optional:false, sequential:false, chain_sym:undefined, kind:0, value:undefined, next:undefined, print:function() { return "?";} }
	
	if (rule.type == "tree" && rule.name == "opt")
	{
		result.optional = true
		rule = rule.children[0]
	}
	
	if (rule.type == "tree" && rule.name == "seq")
	{
		result.sequential = true;
		rule = rule.children[0]
	}
	else if (rule.type == "tree" && rule.name == "chain")
	{
		result.sequential = true;
		result.chain_sym = rule.children[1].value
		rule = rule.children[0]
	}
	else if (rule.type == "tree" && rule.name == "list")
	{
		result.sequential = true;
		result.chain_sym = ","
		rule = rule.children[0]
	}
	
	if (rule.type == "ident")
	{
		if (rule.value == "int" || rule.value == "string" || rule.value == "char" || rule.value == "ident" || rule.value == "eof")
		{
			result.kind = RK_TERM
			result.value = rule.value
			result.print = function(){ return " term " + this.value + print_rule_options(this); }
		}
		else
		{
			result.kind = RK_NT
			var nt = grammar.find_nt(rule.value)
			result.value = nt
			result.print = function(){ return " nt " + this.value.name + print_rule_options(this); }
			var found = false
			for (var j = 0; j < nt.used_in.length; j++)
				if (nt.used_in[j] == in_nt)
				{
					found = true
					break
				}
			if (!found)
				nt.used_in.push(in_nt)
		}
	}
	else if (rule.type == "string")
	{
		result.kind = RK_LIT
		result.value = rule.value
		if (ident_start_char(rule.value.charCodeAt(0)))
			grammar.add_keyword(rule.value)
		result.print = function(){ return " lit " + this.value + print_rule_options(this); }

	}
	else if (rule.type == "list")
	{
		result.kind = RK_GROUP
		result.value = []
		result.print = function(){
			var s = "("
			for (var i = 0; i < this.value.length; i++)
			{
				if (i > 0) s += " |"
				s += (this.value[i].rule != undefined ? this.value[i].rule.print() : "") + " [" + this.value[i].tree_name + "]"
			}
			return s + ")"+ print_rule_options(this);
		}

		for (var i = 0; i < rule.children.length; i++)
		{
			var subrule = rule.children[i]
			if (subrule.type == "tree" && subrule.name == "rule")
			{
				var treename = subrule.children[1]
				if (treename != undefined && treename.type == "tree")
					treename = treename.children[0]
				if (treename != undefined)
					treename = treename.type == "ident" ? treename.value : undefined
			    result.value.push({ tree_name:treename, rule:make_rule(subrule.children[0] != undefined ? subrule.children[0].children : [], 0, grammar, in_nt)})
			}
		}
	}
	result.next = make_rule(children, nr+1, grammar, in_nt)
	return result
}

function make_grammar(tree)
{
	var grammar = { non_terminals:[],
		find_nt(n) {
			for (var i = 0; i < this.non_terminals.length; i++)
				if (this.non_terminals[i].name == n)
					return this.non_terminals[i]
			new_nt = { name:n, normal:[], recursive:[], used_in:[], nr:(this.non_terminals.length + 2) }
			this.non_terminals.push(new_nt)
			return new_nt
		},
		keywords:[],
		has_keyword(s) {
			for (var i = 0; i < this.keywords.length; i++)
				if (this.keywords[i] === s)
					return true
			return false
		},
		add_keyword(s) {
			if (!this.has_keyword(s))
				this.keywords.push(s)
		}}
	for (var i = 0; i < tree.children.length; i++)
	{
		var nt_def_tree = tree.children[i]
		if (nt_def_tree.type == "tree" && nt_def_tree.name == "nt_def")
		{
			var nt_name = nt_def_tree.children[0].value
			var nt = grammar.find_nt(nt_name)
			var rules = nt_def_tree.children[1].children
			for (var j = 0; j < rules.length; j++)
			{
				var rule = rules[j]
				if (rule.type == "tree" && rule.name == "rule")
				{
					if (rule.children.length == 0)
						nt.normal.push({ tree_name:undefined, rule:undefined })
					else
					{
						var parts = rule.children[0]
						var treename = rule.children[1]
						if (treename != undefined && treename.type == "tree")
							treename = treename.children[0]
						if (treename != undefined)
							treename = treename.type == "ident" ? treename.value : undefined
						if (parts == undefined)
							parts = { children:[] }
						if (parts.children.length > 0
							&& parts.children[0].type == "ident"
							&& parts.children[0].value == nt_name)
							nt.recursive.push({ tree_name:treename, rule:make_rule(parts.children, 1, grammar, nt)})
						else
							nt.normal.push({ tree_name:treename, rule:make_rule(parts.children, 0, grammar, nt)})
					}
				}
			}
		}
	}
	return grammar
}

function make_iparse_grammar()
{
	return make_grammar(
	    list_tree([ tree_tree("nt_def",[ ident_tree("root"),
	      list_tree([ tree_tree("rule",[ list_tree([ tree_tree("seq",[ ident_tree("nt_def") ]) ]), undefined
	         ]) ]) ]),
	     tree_tree("nt_def",[ ident_tree("nt_def"),
	      list_tree([ tree_tree("rule",[ list_tree([ ident_tree("ident"),
	         string_tree(":"),
	         ident_tree("or_rule"),
	         string_tree(".") ]),
	        ident_tree("nt_def") ]) ]) ]),
	     tree_tree("nt_def",[ ident_tree("or_rule"),
	      list_tree([ tree_tree("rule",[ list_tree([ tree_tree("chain",[ ident_tree("rule"),
	          string_tree("|") ]) ]), undefined
	         ]) ]) ]),
	     tree_tree("nt_def",[ ident_tree("rule"),
	      list_tree([ tree_tree("rule",[ list_tree([ tree_tree("opt",[ tree_tree("seq",[ ident_tree("opt_elem") ]) ]),
	         tree_tree("opt",[ list_tree([ tree_tree("rule",[ list_tree([ string_tree("["),
	             ident_tree("ident"),
	             string_tree("]") ]), undefined
	             ]) ]) ]) ]),
	        ident_tree("rule") ]) ]) ]),
	     tree_tree("nt_def",[ ident_tree("opt_elem"),
	      list_tree([ tree_tree("rule",[ list_tree([ ident_tree("list_elem"),
	         string_tree("OPT") ]),
	        ident_tree("opt") ]),
	       tree_tree("rule",[ list_tree([ ident_tree("list_elem") ]), undefined
	         ]) ]) ]),
	     tree_tree("nt_def",[ ident_tree("list_elem"),
	      list_tree([ tree_tree("rule",[ list_tree([ ident_tree("prim_elem"),
	         string_tree("SEQ") ]),
	        ident_tree("seq") ]),
	       tree_tree("rule",[ list_tree([ ident_tree("prim_elem"),
	         string_tree("LIST") ]),
	        ident_tree("list") ]),
	       tree_tree("rule",[ list_tree([ ident_tree("prim_elem"),
	         string_tree("CHAIN"),
	         ident_tree("string") ]),
	        ident_tree("chain") ]),
	       tree_tree("rule",[ list_tree([ ident_tree("prim_elem") ]), undefined
	         ]) ]) ]),
	     tree_tree("nt_def",[ ident_tree("prim_elem"),
	      list_tree([ tree_tree("rule",[ list_tree([ ident_tree("string") ]), undefined
	         ]),
	       tree_tree("rule",[ list_tree([ ident_tree("ident") ]), undefined
	         ]),
	       tree_tree("rule",[ list_tree([ string_tree("("),
	         ident_tree("or_rule"),
	         string_tree(")") ]), undefined
	         ]) ]) ]) ])
    )
}

var buffer
var pos
var line
var column
var ch

function save_pos()
{
	return { spos:pos, sline:line, scolumn:column, sch:ch }
}

function restore_pos(sp)
{
	pos = sp.spos
	line = sp.sline
	column = sp.scolumn
	ch = sp.sch
} 

var expect_pos
var expect_line_column
var expects

function expecting(s)
{
	if (pos > expect_pos)
	{
		expect_pos = pos
		expect_line_column = line + ":" + column
		expects = []
	}
	if (expect_pos == pos)
	{
		for (var i = 0; i < expects.length; i++)
			if (expects[i] == s)
				return
		expects.push(s)
	}
}

function report_expecting()
{
 	var left = buffer.length - expect_pos
 	var s = expect_line_column + " at: " + (left < 10 ? buffer.substr(expect_pos, left) + "<eof>" : buffer.substr(expect_pos, 10)).replaceAll("\n", "\\n")
 	for (var i = 0; i < expects.length; i++)
 		s += "\n  " + expects[i]
	return s
}

function next()
{
	pos += 1
	if (pos >= buffer.length)
	{
		ch = 0
	}
	else
	{
		if (ch == 10)
		{
			line += 1
			column = 0
		}
		ch = buffer.charCodeAt(pos)
		column += 1
	}
} 

function skip_space()
{
	for (;;)
	{
		if (ch == 32 || ch == 9 || ch == 10 || ch == 13)
			next()
		else if (ch == 47 && pos+1 < buffer.length && buffer.charCodeAt(pos+1) == 47)
		{
			while (ch != 0 && ch != 10 && ch != 13)
				next();
		}
		else if (ch == 47 && pos+1 < buffer.length && buffer.charCodeAt(pos+1) == 42)
		{
			next()
			next()
			while (ch != 0 && !(ch == 42 && pos+1 < buffer.length && buffer.charCodeAt(pos+1) == 47))
				next()
			if (ch == 42)
			{
				next()
				next()
			}
		}
		else
			break
	}
}

var cache

function accept_string(quote)
{
	if (cache[0].pos == pos)
	{
		if (cache[0].success)
		{
			restore_pos(cache[0].endsp)
			return cache[0].result
		}
		else
			return undefined
	}
	if (ch != quote)
	{
		expecting("<string>")
		return undefined
	}
	cache[0].pos = pos
	var sp = save_pos()
	next()
	var str = ""
	while (ch != 0 && ch != quote && ch != 13)
	{
		if (ch == 92)
		{
			str += buffer[pos]
			next()
			if (ch == 0)
				break
		}
		str += buffer[pos]
		next()
	}
	if (ch != quote)
	{
		restore_pos(sp)
		cache[0].success = false
		expecting("<string> (not terminated)")
		return undefined
	}
	next()
	skip_space()
	cache[0].success = true
	cache[0].endsp = save_pos()
	cache[0].result = str
	return str
}

function accept_id()
{
	if (ident_start_char(ch))
	{
		if (cache[1].pos == pos)
		{
			restore_pos(cache[1].endsp)
			return cache[1].result
		}
		cache[1].pos = pos
		var id = buffer[pos]
		next()
		while (ident_start_char(ch) || (48 <= ch && ch <= 57))
		{
			id += buffer[pos]
			next()
		}
		skip_space()
		cache[1].endsp = save_pos()
		cache[1].result = id
		return id
	}
	return undefined
}

function accept_ident(grammar)
{
	var sp = save_pos()
	var id = accept_id()
	if (id != undefined && !grammar.has_keyword(id))
		return id
	restore_pos(sp)
	expecting("<ident>")
	return undefined
}

function accept_int()
{
	var sp = save_pos()
	var str = ""
	if (ch == 45)
	{
		str = "-"
		next()
	}
	if (48 <= ch && ch <= 57)
	{
		while (48 <= ch && ch <= 57)
		{
			str += buffer[pos]
			next()
		}
		skip_space()
		return parseInt(str)
	}
	restore_pos(sp)
	expecting("<int>")
	return undefined
}

function accept_lit(s, grammar)
{
	if (ident_start_char(s.charCodeAt(0)))
	{
		var sp = save_pos()
		var id = accept_id()
		if (id != undefined && id === s)
			return true
		restore_pos(sp)
		expecting(s + " (keyword)")
		return false
	}
	if (pos + s.length <= buffer.length && buffer.substr(pos, s.length) === s)
	{
		for (var i = 0; i < s.length; i++)
			next()
		skip_space()
		return true;
	}
	expecting(s)
	return false
}

function parse_term(term, rtree, grammar)
{
	if (term == "int")
	{
		var i = accept_int()
		if (i == undefined)
			return false
		rtree.result = int_tree(i)
		return true
	}
	if (term == "ident")
	{
		var i = accept_ident(grammar)
		if (i == undefined)
			return false
		rtree.result = ident_tree(i)
		return true
	}
	if (term == "string")
	{
		var s = accept_string(34)
		if (s == undefined)
			return false
		rtree.result = string_tree(s)
		return true
	}
	if (term == "char")
	{
		var s = accept_string(39)
		if (s == undefined)
			return false
		rtree.result = char_tree(s)
		return true
	}
	if (term == "eof")
	{
		return ch == 0
	}
	return false
}

function parse_nt(non_term, rtree, grammar)
{
	var c = cache[non_term.nr]
	if (c.pos == pos)
	{
		if (c.success)
		{
			rtree.result = c.result
			restore_pos(c.endsp)
			return true
		}
		return false
	}
	c.pos = pos
	c.success = false
	for (var i = 0; i < non_term.normal.length; i++)
		if (parse_rule(non_term.normal[i].rule, undefined, non_term.normal[i].tree_name, rtree, grammar))
		{
			if (non_term.recursive.length > 0)
			{
				for (;;)
				{
					var i = 0
					for (; i < non_term.recursive.length; i++)
						if (parse_rule(non_term.recursive[i].rule, { last:rtree.result }, non_term.recursive[i].tree_name, rtree, grammar))
							break;
					if (i == non_term.recursive.length)
						break;
				}
			}
			
			c.success = true
			c.endsp = save_pos()
			c.result = rtree.result
			return true
		}
	//expecting("non terminal: "+non_term.name)
	return false
}

function parse_or(or, rtree, grammar)
{
	for (var i = 0; i < or.length; i++)
		if (parse_rule(or[i].rule, undefined, or[i].tree_name, rtree, grammar))
			return true
	return false
}

function parse_rule(rule, prev_parts, tree_name, rtree, grammar)
{
	if (rule == undefined)
	{
		if (tree_name != undefined)
		{
			rtree.result = tree_tree(tree_name)
			for (var parts = prev_parts; parts != null; parts = parts.prev)
				rtree.result.children.unshift(parts.last)
		}
		else if (prev_parts != undefined)
		{
			if (prev_parts.prev == undefined)
				rtree.result = prev_parts.last
			else
			{
				rtree.result = list_tree()
				for (var parts = prev_parts; parts != null; parts = parts.prev)
					rtree.result.children.unshift(parts.last)
			}
		}
		return true
	}
	
	var sp = save_pos()
	
	var go = false
	var t = { result:undefined }
	if (rule.kind == RK_TERM)
		go = parse_term(rule.value, t, grammar)
	else if (rule.kind == RK_NT)
		go = parse_nt(rule.value, t, grammar)
	else if (rule.kind == RK_LIT)
	{
		if (accept_lit(rule.value, grammar))
		{
			if (rule.sequential)
			{
				var seq = list_tree()
				
				if (parse_seq(rule, seq, prev_parts, tree_name, rtree, grammar))
					return true
			}
			else if (parse_rule(rule.next, prev_parts, tree_name, rtree, grammar))
				return true
		}
		else if (rule.optional)
		{
			if (parse_rule(rule.next, prev_parts, tree_name, rtree, grammar))
				return true
		}
		restore_pos(sp)
		return false
	}
	else if (rule.kind == RK_GROUP)
		go = parse_or(rule.value, t, grammar)
	
	if (go)
	{
		if (rule.sequential)
		{
			var seq = list_tree()
			seq.children.push(t.result)
			
			if (parse_seq(rule, seq, prev_parts, tree_name, rtree, grammar))
				return true
		}
		else if (parse_rule(rule.next, { prev:prev_parts, last:t.result }, tree_name, rtree, grammar))
			return true
	}
	
	if (rule.optional)
	{
		restore_pos(sp)
		
		if (parse_rule(rule.next, { prev:prev_parts, last:undefined }, tree_name, rtree, grammar))
			return true
	}
	restore_pos(sp)
	return false
}

function parse_seq(rule, seq, prev_parts, tree_name, rtree, grammar)
{
	var sp = save_pos()
	
	if (rule.chain_sym == undefined || accept_lit(rule.chain_sym, grammar))
	{
		var go = false
		var t = { result:undefined }
		if (rule.kind == RK_TERM)
			go = parse_term(rule.value, t, grammar)
		else if (rule.kind == RK_NT)
			go = parse_nt(rule.value, t, grammar)
		else if (rule.kind == RK_GROUP)
			go = parse_or(rule.value, t, grammar)
		
		if (go)
		{
			seq.children.push(t.result)
			if (parse_seq(rule, seq, prev_parts, tree_name, rtree, grammar))
				return true
			seq.children.pop()
		}
	}
	
	restore_pos(sp)
	
	if (parse_rule(rule.next, { prev:prev_parts, last:seq }, tree_name, rtree, grammar))
		return true

	restore_pos(sp)

	return false
}

function parse_text(s, grammar)
{
	buffer = s
	pos = 0
	line = 1
	column = 1
	expect_pos = -1
	expect_line_column = "?"
	expects = []
	ch = buffer.length == 0 ? 0 : buffer.charCodeAt(0)
	skip_space()
	cache = []
	for (var i = 0; i < grammar.non_terminals.length + 2; i++)
		cache.push({ pos:-1, success:false, endsp:undefined, result:undefined})
	rtree = { result:undefined }
	if (parse_nt(grammar.find_nt("root"), rtree, grammar) && ch == 0)
		return rtree.result
	return false
}

var iparse_grammar = make_iparse_grammar()


function print_grammar(grammar)
{
 var s = ""
 for (var i = 0; i < grammar.non_terminals.length; i++)
 {
	var non_term = grammar.non_terminals[i]
 	s += "nt " + non_term.name + "\n"
 	for (var j = 0; j < non_term.normal.length; j++)
 	{
 		s += " normal: " + (non_term.normal[j].rule != undefined ? non_term.normal[j].rule.print() : "") + "[" + non_term.normal[j].tree_name + "]\n"
 	}
 	for (var j = 0; j < non_term.recursive.length; j++)
 	{
 		s += " recursive: " + (non_term.recursive[j].rule != undefined ? non_term.recursive[j].rule.print() : "") + "[" + non_term.recursive[j].tree_name + "]\n"
 	}
 }
 for (var i = 0; i < grammar.keywords.length; i++)
 	s += "keyword " + grammar.keywords[i] + "\n"
 return s
}

var the_grammar

function parse_grammar_input()
{
 the_grammar = undefined
 document.P.output.value=""

 grammar = document.P.grammar.value;
 input_pos=0;

 var grammar_tree = parse_text(document.P.grammar.value, iparse_grammar)
 if (grammar_tree == false)
 {
 	document.P.grammar_error.value = report_expecting()
 	document.P.output.value = "(grammar has errors)"
 	d3Tree({ name:"<Grammar has errors>", children:[] })
 	return
 }

 //document.P.grammar_error.value = "OK\n"+rtree.result.print()
 var input_grammar = make_grammar(grammar_tree)
 var s = ""
 var s2 = ""
 var found_root = false
 for (var i = 0; i < input_grammar.non_terminals.length; i++)
 	if (input_grammar.non_terminals[i].name == "root")
 	{
 		found_root = true
 		break
 	}
 if (!found_root)
 	s += "Error: There is no 'root' non-terminal\n"
 for (var i = 0; i < input_grammar.non_terminals.length; i++)
 {
 	var nt = input_grammar.non_terminals[i]
 	//s += nt.name + ": " + nt.normal.length + "\n"
 	if (nt.normal.length == 0)
 	{
 		s += "Error: Non-terminal '"+nt.name+"'"
 		if (nt.used_in.length > 0)
 		{
 			s += " (used in"
 			for (var j = 0; j < nt.used_in.length; j++)
 			{
 				if (j > 0)
 					s += ", "
 				s += "'"+nt.used_in[j].name+"'"
 			}
 			s += ")"
 		}
 		s += " has no normal rules\n"
 	}
 }
 for (var i = 0; i < input_grammar.non_terminals.length; i++)
 {
	var nt = input_grammar.non_terminals[i]
 	//s2 += nt.name + ": Used in"
 	//for (var j = 0; j < nt.used_in.length; j++)
 	//	s2 += " "+nt.used_in[j].name
 	//s2 += "\n"
 	if (nt.name != "root")
 	{
 		if (nt.used_in.length == 0)
 			s2 += "Warning: Non-terminal '"+nt.name+"' is not used in other rule\n"
 		else if (nt.used_in.length == 1 && nt.used_in[0] == nt)
 			s2 += "Warning: Non-terminal '"+nt.name+"' is only used in itself\n"
	}
 }
 if (s != "")
 {
 	document.P.grammar_error.value = s + s2
 	document.P.output.value = "(grammar has errors)"
 	return
 }
 document.P.grammar_error.value = s2 + print_grammar(input_grammar)
 the_grammar = input_grammar
 parse_input()
}

var input_tree = undefined

function countAtMost20(t)
{
	var nr = 1
	if (t != undefined && t.children != undefined)
		for (var i = 0; i < t.children.length; i++)
		{
			nr += countAtMost20(t.children[i])
			if (nr >= 20)
				break;
		}
	return nr;
}

function parse_input()
{
	if (the_grammar == undefined)
	{
		document.P.output.value = "(grammar has errors)"
		d3Tree({ name:"<Grammar has errors>", children:[] })
		showTree()
		return
	}
	input_tree = parse_text(document.P.input.value, the_grammar)
	if (input_tree == false)
	{
		document.P.output.value = report_expecting()
		d3Tree({ name:"<input has errors>", children:[] })
		return
	}
	document.P.output.value = input_tree != undefined ? input_tree.print() : ""
	if (input_tree == undefined || countAtMost20(input_tree) <= 20)
		showTree()
}


function spaces(i)
{var r="";
 while(i>0){i-=1;r+=" ";}
 return r;
}

function printx(v)
{
	var s = "(name:"+v.name+",["
	if (v.children == undefined)
		s += "undefined"
	for (var i = 0; i < v.children.length; i++)
	{
		if (i > 0)
			s += ","
		s += printx(v.children[i])
	}
	return s + "]"
}
function showTree()
{
	//document.P.output.value = printx(input_tree.transf())
	d3Tree(input_tree == undefined ? { name:"<NULL>", children:[] } : input_tree == false ? { name:"<input has errors>", children:[] } : input_tree.transf() )
}

// -->
</SCRIPT>

<TITLE>Interactive parser</TITLE>
</HEAD><BODY>

<NOSCRIPT>
<FONT COLOR="#FF0000">
This page requires <B>JavaScript</B> to be enabled.
</FONT>
</NOSCRIPT>

<H1>Interactive parser</H1>

This page gives an interactive parser, which allows you to enter a grammar
and use it to parse some input. It can be a helpful tool in developping a
grammar and testing it agains example input. The parser is a reimplementation
of (a subset of) <A HREF="https://github.com/FransFaase/IParse">IParse</A>, an
interpretting parser, in JavaScript and responds to keystrokes, which
gives immediate response to the grammar and input being entered.
<P>
This was created as part of <A HREF="https://fransfaase.github.io/ParserWorkshop/"
>an online workshop</A> on parsing.
The code for showing the syntax tree is based on <A HREF="http://christos-c.com/treeviewer/"
>Syntactic Tree Viewer</A> by <A HREF="http://christos-c.com/">Christos
Christodoulopoulos</A>, which makes use of <A HREF="https://d3js.org/"
>d3.js</A> and itself is inspired by <A HREF="https://gist.github.com/robschmuecker/7880033"
>D3.js Drag and Drop Zoomable Tree</A> by <A HREF="https://gist.github.com/robschmuecker"
>Rob Schmuecker</A>.

<H2><A NAME="grammar">Grammar description</A></H2>

To parse input that consists of an integer, an identifier and a string, the
following grammar can be used:
<PRE>
root : int ident string .
</PRE>
This grammar consists of one production rule. The production rule starts with
the <TT>root</TT> non-terminal, which is the non-terminal that is used to parse
the whole input. After the colon the elements of the production rule are given.
The element can be terminals and non-terminals. In this case it consists of three
terminals. At the end of the production rule a period is placed. There are
three predefined terminals defined:
<UL>
<LI><TT>int</TT>: parses a whole number
<LI><TT>ident</TT>: parses a identifier, starting with an alphabetic character
	or an underscore followed by zero or more alphabetic characts, underscores
	or numerical characters.
<LI><TT>string</TT>: parses a string surrounded with double quotes.
	The back-slash character acts as an escape character.
<LI><TT>char</TT>: parses a character surrounded with single quotes.
	The back-slash character acts as an escape character.
</UL>
An example input that should parse correctly is:
<PRE>
123 abc "test ?*"
</PRE>
The <A HREF="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract
syntax tree</A> of the parsing is printed as:
<PRE>
(int:123,ident:abc,string:"test ?*")
</PRE>
<P>
The following grammar parses the same input as the above, but now it uses
two extra non-terminal and two additional production rule for those
non-terminals:
<PRE>
root : first rest .
first : int
rest : ident string .
</PRE>
<P>
To parse input that consists of the keyword <TT>if</TT> followed by an
identifier between round brackets, the following grammar can be used:
<PRE>
root : "if" "(" ident ")" .
</PRE>
In this grammar rule, literal strings, between double quotes are used as
additional terminals in the grammar. Literal strings that start with an
alphabetic character are treated as keywords, meaning that it should be
terminated with a non-identifier character. It also means that it is excluded
as a valid identifier. An example of input that should parse correctly is:
<PRE>
if ( a )
</PRE>
The following input is not parsed correctly, because although it starts with
<TT>if</TT> it does not start with an identifier that is equal to <TT>if</TT>
<PRE>
iff ( a )
</PRE>
The following input does not parse correctly, because <TT>if</TT> is no longer
a valid identifier:
<PRE>
if ( if )
</PRE>
<P>
To parse input that consists an optional integer, one or more identifiers, and
zero or more strings, the following grammar can be used:
<PRE>
root : int OPT 
       ident SEQ
       string SEQ OPT .
</PRE>
The <TT>OPT</TT> placed after an element indicates that the elements is
optional. The <TT>SEQ</TT> placed after an element indicates that the element
can occur one or more times. The combination of <TT>SEQ</TT> and <TT>OPT</TT>
indicates that the element can occur zero or more times.
<P>
To parse input that consists of a sum of integers, the following grammar can
be used:
<PRE>
root : int CHAIN "+"
</PRE>
The <TT>CHAIN</TT> followed by a literal indicates a chain sequence, where the
literal is used as a separator between the elements. An example input is:
<PRE>
1 + 6 + 5
</PRE>
The <TT>LIST</TT> is a shorthand for a chain sequence with a comma.
<P>
To parse input that consists of intermixed list of integers and identifiers
(separated by commas), the following grammar can be used:
<PRE>
root : ( int | ident ) LIST .
</PRE>
This will parse an input like:
<PRE>
ad, 4, 5, gh, jk
</PRE>
This grammar rule shows the use of brackets to group elements and the
vertical bar character to separate alternatives. The vertical bar can also
be used to combine several production rules for one non-terminal together.
<P>
When the input parses correctly, an abstract syntax tree is displayed in the
text area to the right of the input. To annotate this abstract syntax tree, it
is possible to annotate the production rules with identifiers between square
brackets. An example of this is given in the grammar below, a grammar for
simple expressions to add, multiply, and divide numbers:
<PRE>
root : E .
E : F CHAIN "+" [sum].
F : T | F "*" T [times] | F "/" T [div].
T : int | "(" E ")".
</PRE>
<P>
Whitespace is accepted between all the terminals. As whitespace the space,
the tab and the newline characters are accepted and also the two types of
comments that are allowed in the C-language: Any text between <TT>/*</TT> and
<TT>*/</TT> and the remainder of the line followed by a <TT>//</TT> sequence.
<P>
For educational purposes, the rules with respect to the specification of
terminals are limited. For more options, see the C++ implementation of
<A HREF="https://github.com/FransFaase/IParse">IParse</A> and the C
implementation of <A HREF="https://github.com/FransFaase/RawParser"
>RawParser</A>.

<H2>Interactive parser</H2>

Below you can enter a grammar and some input to be parsed according to the
grammar. On the left are the input text areas. At every keystroke (or clicking
the execute button) the grammar will be parsed and if it is without errors,
the input below is parsed according to the given grammar. Errors and results
are shown in the text areas on the right.
<P>
<FORM NAME="P">
Enter the grammar:<BR>
<TEXTAREA NAME="grammar" ROWS="20" COLS="80" onkeyup="parse_grammar_input()"></TEXTAREA>
<TEXTAREA NAME="grammar_error" ROWS="20" COLS="80"></TEXTAREA>
<P>
The input to be parsed by the grammar:<BR>
<TEXTAREA NAME="input" ROWS="20" COLS="80" onkeyup="parse_input()"></TEXTAREA>
<TEXTAREA NAME="output" ROWS="20" COLS="80"></TEXTAREA>
<P>
<INPUT TYPE="button" VALUE="execute" ONCLICK="parse_grammar_input()">
<INPUT TYPE="button" VALUE="show tree" ONCLICK="return showTree();">
<P>
<DIV ID="tree-container"></DIV>
<SCRIPT>
<!--
parse_grammar_input()
//-->
</SCRIPT>
<!--
<P>
Output generated by IParse:<BR>
<P>
</FORM>

<SVG VIEWBOX="0 0 60 20" ID="tree">
<P>
Text
<SCRIPT><!- -
var svgtree = document.getElementById("tree")
svgtree.innerHTML = "<rect width=\"60\" height=\"20\" fill=\"#eee\"></rect><text font-size=\"5px\" x=\"2\" y=\"8\">Inline SVG</text>"
//- -></SCRIPT>
-->

</BODY></HTML>

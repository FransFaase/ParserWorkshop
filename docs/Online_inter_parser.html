<HTML><HEAD>
<SCRIPT SRC="d3.v3.min.js"></SCRIPT>
<SCRIPT SRC="d3Tree.js"></SCRIPT>
<link rel="stylesheet" type="text/css" href="tree-viewer.css">
<SCRIPT>
<!--

function int_tree(i)
{
	return { type:"int", value:i, print:function() { return "int:"+this.value; }, transf:function() { return { name:("int:" + this.value)} } }
}

function double_tree(d)
{
	return { type:"double", value:d, print:function() { return "double:"+this.value; }, transf:function() { return { name:("double:" + this.value)} } }
}

function ident_tree(n)
{
	return { type:"ident", value:n, print:function() { return "ident:"+this.value; }, transf:function() { return { name:("ident:" + this.value)} } }
}

function string_tree(s)
{
	return { type:"string", value:s, print:function() { return "string:\""+this.value+"\""; }, transf:function() { return { name:("string:\"" + this.value + "\"")} } }
}

function char_tree(s)
{
	return { type:"char", value:s, print:function() { return "char:'"+this.value+"'"; }, transf:function() { return { name:("char:'" + this.value + "'")} } }
}

function _tl_tree(t, n, c)
{
	return { type:t, name:n, children:c,
		print:function()
		{
			var s = this.type == "tree" ? this.name + "(" : "(";
			for (var i = 0; i < this.children.length; i++)
			{
				if (i > 0)
					s += ","
				if (this.children[i] == undefined)
					s += "<NULL>"
				else
					s += this.children[i].print()
			}
			return s + ")"
		},
		transf:function()
		{
			if (this.type == "list" && this.children.length == 1)
				return this.children[0].transf()
			var children = this.children.length == 1 && this.children[0] != undefined && this.children[0].type == "list" ? this.children[0].children : this.children
			var childs = []
			for (var i = 0; i < children.length; i++)
				if (children[i] == undefined)
					childs.push({name:"<NULL>"})
				else
					childs.push(children[i].transf())
			return { name:(this.type == "tree" ? this.name : "LIST"), children:childs }
		}
	}
}

function tree_tree(n, c=[]) { return _tl_tree("tree", n, c) }
function list_tree(c=[]) { return _tl_tree("list", undefined, c) }

function add_child(t, c)
{
	t.children.push(c)
}


var RK_TERM = 1
var RK_NT = 2
var RK_LIT = 3
var RK_GROUP = 4

function ident_start_char(ch) { return (65 <= ch && ch <= 90) || (97 <= ch && ch <= 122) || ch == 95; }

function print_rule_options(rule)
{
	var s = ""
	if (rule.chain_sym != undefined)
		s += " CHAIN '"+rule.chain_sym+"'"
	else if (rule.sequential)
		s += " SEQ"
	if (rule.optional)
		s += " OPT"
	if (rule.next != undefined)
		s += rule.next.print()
	return s
}

function make_rule(children, nr, grammar, in_nt)
{
	if (nr >= children.length) return undefined
	var rule = children[nr]

	if (rule == undefined)
	{
		return undefined;
	}
		
	var result = { optional:false, sequential:false, chain_sym:undefined, kind:0, value:undefined, next:undefined, print:function() { return "?";} }
	
	if (rule.type == "tree" && rule.name == "opt")
	{
		result.optional = true
		rule = rule.children[0]
	}
	
	if (rule.type == "tree" && rule.name == "seq")
	{
		result.sequential = true;
		rule = rule.children[0]
	}
	else if (rule.type == "tree" && rule.name == "chain")
	{
		result.sequential = true;
		result.chain_sym = rule.children[1].value
		rule = rule.children[0]
	}
	else if (rule.type == "tree" && rule.name == "list")
	{
		result.sequential = true;
		result.chain_sym = ","
		rule = rule.children[0]
	}
	
	if (rule.type == "ident")
	{
		if (rule.value == "int" || rule.value == "string" || rule.value == "char" || rule.value == "ident" || rule.value == "eof")
		{
			result.kind = RK_TERM
			result.value = rule.value
			result.print = function(){ return " term " + this.value + print_rule_options(this); }
		}
		else
		{
			result.kind = RK_NT
			var nt = grammar.find_nt(rule.value)
			result.value = nt
			result.print = function(){ return " nt " + this.value.name + print_rule_options(this); }
			var found = false
			for (var j = 0; j < nt.used_in.length; j++)
				if (nt.used_in[j] == in_nt)
				{
					found = true
					break
				}
			if (!found)
				nt.used_in.push(in_nt)
		}
	}
	else if (rule.type == "string")
	{
		result.kind = RK_LIT
		result.value = rule.value
		if (ident_start_char(rule.value.charCodeAt(0)))
			grammar.add_keyword(rule.value)
		result.print = function(){ return " lit " + this.value + print_rule_options(this); }

	}
	else if (rule.type == "list")
	{
		result.kind = RK_GROUP
		result.value = []
		result.print = function(){
			var s = "("
			for (var i = 0; i < this.value.length; i++)
			{
				if (i > 0) s += " |"
				s += (this.value[i].rule != undefined ? this.value[i].rule.print() : "") + " [" + this.value[i].tree_name + "]"
			}
			return s + ")"+ print_rule_options(this);
		}

		for (var i = 0; i < rule.children.length; i++)
		{
			var subrule = rule.children[i]
			if (subrule.type == "tree" && subrule.name == "rule")
			{
				var treename = subrule.children[1]
				if (treename != undefined && treename.type == "tree")
					treename = treename.children[0]
				if (treename != undefined)
					treename = treename.type == "ident" ? treename.value : undefined
			    result.value.push({ tree_name:treename, rule:make_rule(subrule.children[0] != undefined ? subrule.children[0].children : [], 0, grammar, in_nt)})
			}
		}
	}
	result.next = make_rule(children, nr+1, grammar, in_nt)
	return result
}

function make_grammar(tree)
{
	var grammar = { non_terminals:[],
		find_nt(n) {
			for (var i = 0; i < this.non_terminals.length; i++)
				if (this.non_terminals[i].name == n)
					return this.non_terminals[i]
			new_nt = { name:n, normal:[], recursive:[], used_in:[], nr:(this.non_terminals.length + 2) }
			this.non_terminals.push(new_nt)
			return new_nt
		},
		keywords:[],
		has_keyword(s) {
			for (var i = 0; i < this.keywords.length; i++)
				if (this.keywords[i] === s)
					return true
			return false
		},
		add_keyword(s) {
			if (!this.has_keyword(s))
				this.keywords.push(s)
		}}
	for (var i = 0; i < tree.children.length; i++)
	{
		var nt_def_tree = tree.children[i]
		if (nt_def_tree.type == "tree" && nt_def_tree.name == "nt_def")
		{
			var nt_name = nt_def_tree.children[0].value
			var nt = grammar.find_nt(nt_name)
			var rules = nt_def_tree.children[1].children
			for (var j = 0; j < rules.length; j++)
			{
				var rule = rules[j]
				if (rule.type == "tree" && rule.name == "rule")
				{
					if (rule.children.length == 0)
						nt.normal.push({ tree_name:undefined, rule:undefined })
					else
					{
						var parts = rule.children[0]
						var treename = rule.children[1]
						if (treename != undefined && treename.type == "tree")
							treename = treename.children[0]
						if (treename != undefined)
							treename = treename.type == "ident" ? treename.value : undefined
						if (parts == undefined)
							parts = { children:[] }
						if (parts.children.length > 0
							&& parts.children[0].type == "ident"
							&& parts.children[0].value == nt_name)
							nt.recursive.push({ tree_name:treename, rule:make_rule(parts.children, 1, grammar, nt)})
						else
							nt.normal.push({ tree_name:treename, rule:make_rule(parts.children, 0, grammar, nt)})
					}
				}
			}
		}
	}
	return grammar
}

function make_iparse_grammar()
{
	return make_grammar(
	    list_tree([ tree_tree("nt_def",[ ident_tree("root"),
	      list_tree([ tree_tree("rule",[ list_tree([ tree_tree("seq",[ ident_tree("nt_def") ]) ]), undefined
	         ]) ]) ]),
	     tree_tree("nt_def",[ ident_tree("nt_def"),
	      list_tree([ tree_tree("rule",[ list_tree([ ident_tree("ident"),
	         string_tree(":"),
	         ident_tree("or_rule"),
	         string_tree(".") ]),
	        ident_tree("nt_def") ]) ]) ]),
	     tree_tree("nt_def",[ ident_tree("or_rule"),
	      list_tree([ tree_tree("rule",[ list_tree([ tree_tree("chain",[ ident_tree("rule"),
	          string_tree("|") ]) ]), undefined
	         ]) ]) ]),
	     tree_tree("nt_def",[ ident_tree("rule"),
	      list_tree([ tree_tree("rule",[ list_tree([ tree_tree("opt",[ tree_tree("seq",[ ident_tree("opt_elem") ]) ]),
	         tree_tree("opt",[ list_tree([ tree_tree("rule",[ list_tree([ string_tree("["),
	             ident_tree("ident"),
	             string_tree("]") ]), undefined
	             ]) ]) ]) ]),
	        ident_tree("rule") ]) ]) ]),
	     tree_tree("nt_def",[ ident_tree("opt_elem"),
	      list_tree([ tree_tree("rule",[ list_tree([ ident_tree("list_elem"),
	         string_tree("OPT") ]),
	        ident_tree("opt") ]),
	       tree_tree("rule",[ list_tree([ ident_tree("list_elem") ]), undefined
	         ]) ]) ]),
	     tree_tree("nt_def",[ ident_tree("list_elem"),
	      list_tree([ tree_tree("rule",[ list_tree([ ident_tree("prim_elem"),
	         string_tree("SEQ") ]),
	        ident_tree("seq") ]),
	       tree_tree("rule",[ list_tree([ ident_tree("prim_elem"),
	         string_tree("LIST") ]),
	        ident_tree("list") ]),
	       tree_tree("rule",[ list_tree([ ident_tree("prim_elem"),
	         string_tree("CHAIN"),
	         ident_tree("string") ]),
	        ident_tree("chain") ]),
	       tree_tree("rule",[ list_tree([ ident_tree("prim_elem") ]), undefined
	         ]) ]) ]),
	     tree_tree("nt_def",[ ident_tree("prim_elem"),
	      list_tree([ tree_tree("rule",[ list_tree([ ident_tree("string") ]), undefined
	         ]),
	       tree_tree("rule",[ list_tree([ ident_tree("ident") ]), undefined
	         ]),
	       tree_tree("rule",[ list_tree([ string_tree("("),
	         ident_tree("or_rule"),
	         string_tree(")") ]), undefined
	         ]) ]) ]) ])
    )
}

var buffer
var pos
var line
var column
var ch

function save_pos()
{
	return { spos:pos, sline:line, scolumn:column, sch:ch }
}

function restore_pos(sp)
{
	pos = sp.spos
	line = sp.sline
	column = sp.scolumn
	ch = sp.sch
} 

var expect_pos
var expect_line_column
var expects

function expecting(s)
{
	if (pos > expect_pos)
	{
		expect_pos = pos
		expect_line_column = line + ":" + column
		expects = []
	}
	if (expect_pos == pos)
	{
		for (var i = 0; i < expects.length; i++)
			if (expects[i] == s)
				return
		expects.push(s)
	}
}

function report_expecting()
{
 	var left = buffer.length - expect_pos
 	var s = expect_line_column + " at: " + (left < 10 ? buffer.substr(expect_pos, left) + "<eof>" : buffer.substr(expect_pos, 10)).replaceAll("\n", "\\n")
 	for (var i = 0; i < expects.length; i++)
 		s += "\n  " + expects[i]
	return s
}

function next()
{
	pos += 1
	if (pos >= buffer.length)
	{
		ch = 0
	}
	else
	{
		if (ch == 10)
		{
			line += 1
			column = 0
		}
		ch = buffer.charCodeAt(pos)
		column += 1
	}
} 

function skip_space()
{
	for (;;)
	{
		if (ch == 32 || ch == 9 || ch == 10 || ch == 13)
			next()
		else if (ch == 47 && pos+1 < buffer.length && buffer.charCodeAt(pos+1) == 47)
		{
			while (ch != 0 && ch != 10 && ch != 13)
				next();
		}
		else if (ch == 47 && pos+1 < buffer.length && buffer.charCodeAt(pos+1) == 42)
		{
			next()
			next()
			while (ch != 0 && !(ch == 42 && pos+1 < buffer.length && buffer.charCodeAt(pos+1) == 47))
				next()
			if (ch == 42)
			{
				next()
				next()
			}
		}
		else
			break
	}
}

var cache

function accept_string(quote)
{
	if (cache[0].pos == pos)
	{
		if (cache[0].success)
		{
			restore_pos(cache[0].endsp)
			return cache[0].result
		}
		else
			return undefined
	}
	if (ch != quote)
	{
		expecting("<string>")
		return undefined
	}
	cache[0].pos = pos
	var sp = save_pos()
	next()
	var str = ""
	while (ch != 0 && ch != quote && ch != 13)
	{
		if (ch == 92)
		{
			str += buffer[pos]
			next()
			if (ch == 0)
				break
		}
		str += buffer[pos]
		next()
	}
	if (ch != quote)
	{
		restore_pos(sp)
		cache[0].success = false
		expecting("<string> (not terminated)")
		return undefined
	}
	next()
	skip_space()
	cache[0].success = true
	cache[0].endsp = save_pos()
	cache[0].result = str
	return str
}

function accept_id()
{
	if (ident_start_char(ch))
	{
		if (cache[1].pos == pos)
		{
			restore_pos(cache[1].endsp)
			return cache[1].result
		}
		cache[1].pos = pos
		var id = buffer[pos]
		next()
		while (ident_start_char(ch) || (48 <= ch && ch <= 57))
		{
			id += buffer[pos]
			next()
		}
		skip_space()
		cache[1].endsp = save_pos()
		cache[1].result = id
		return id
	}
	return undefined
}

function accept_ident(grammar)
{
	var sp = save_pos()
	var id = accept_id()
	if (id != undefined && !grammar.has_keyword(id))
		return id
	restore_pos(sp)
	expecting("<ident>")
	return undefined
}

function accept_int()
{
	var sp = save_pos()
	var str = ""
	if (ch == 45)
	{
		str = "-"
		next()
	}
	if (48 <= ch && ch <= 57)
	{
		while (48 <= ch && ch <= 57)
		{
			str += buffer[pos]
			next()
		}
		skip_space()
		return parseInt(str)
	}
	restore_pos(sp)
	expecting("<int>")
	return undefined
}

function accept_lit(s, grammar)
{
	if (ident_start_char(s.charCodeAt(0)))
	{
		var sp = save_pos()
		var id = accept_id()
		if (id != undefined && id === s)
			return true
		restore_pos(sp)
		expecting(s + " (keyword)")
		return false
	}
	if (pos + s.length <= buffer.length && buffer.substr(pos, s.length) === s)
	{
		for (var i = 0; i < s.length; i++)
			next()
		skip_space()
		return true;
	}
	expecting(s)
	return false
}

function parse_term(term, rtree, grammar)
{
	if (term == "int")
	{
		var i = accept_int()
		if (i == undefined)
			return false
		rtree.result = int_tree(i)
		return true
	}
	if (term == "ident")
	{
		var i = accept_ident(grammar)
		if (i == undefined)
			return false
		rtree.result = ident_tree(i)
		return true
	}
	if (term == "string")
	{
		var s = accept_string(34)
		if (s == undefined)
			return false
		rtree.result = string_tree(s)
		return true
	}
	if (term == "char")
	{
		var s = accept_string(39)
		if (s == undefined)
			return false
		rtree.result = char_tree(s)
		return true
	}
	if (term == "eof")
	{
		return ch == 0
	}
	return false
}

function parse_nt(non_term, rtree, grammar)
{
	var c = cache[non_term.nr]
	if (c.pos == pos)
	{
		if (c.success)
		{
			rtree.result = c.result
			restore_pos(c.endsp)
			return true
		}
		return false
	}
	var start_pos = pos
	c.pos = start_pos
	c.success = false
	for (var i = 0; i < non_term.normal.length; i++)
		if (parse_rule(non_term.normal[i].rule, undefined, non_term.normal[i].tree_name, rtree, grammar))
		{
			if (non_term.recursive.length > 0)
			{
				for (;;)
				{
					var i = 0
					for (; i < non_term.recursive.length; i++)
						if (parse_rule(non_term.recursive[i].rule, { last:rtree.result }, non_term.recursive[i].tree_name, rtree, grammar))
							break;
					if (i == non_term.recursive.length)
						break;
				}
			}
			
			c.pos = start_pos
			c.success = true
			c.endsp = save_pos()
			c.result = rtree.result
			return true
		}
	//expecting("non terminal: "+non_term.name)
	return false
}

function parse_or(or, rtree, grammar)
{
	for (var i = 0; i < or.length; i++)
		if (parse_rule(or[i].rule, undefined, or[i].tree_name, rtree, grammar))
			return true
	return false
}

function parse_rule(rule, prev_parts, tree_name, rtree, grammar)
{
	if (rule == undefined)
	{
		if (tree_name != undefined)
		{
			rtree.result = tree_tree(tree_name)
			for (var parts = prev_parts; parts != null; parts = parts.prev)
				rtree.result.children.unshift(parts.last)
		}
		else if (prev_parts != undefined)
		{
			if (prev_parts.prev == undefined)
				rtree.result = prev_parts.last
			else
			{
				rtree.result = list_tree()
				for (var parts = prev_parts; parts != null; parts = parts.prev)
					rtree.result.children.unshift(parts.last)
			}
		}
		return true
	}
	
	var sp = save_pos()
	
	var go = false
	var t = { result:undefined }
	if (rule.kind == RK_TERM)
		go = parse_term(rule.value, t, grammar)
	else if (rule.kind == RK_NT)
		go = parse_nt(rule.value, t, grammar)
	else if (rule.kind == RK_LIT)
	{
		if (accept_lit(rule.value, grammar))
		{
			if (rule.sequential)
			{
				var seq = list_tree()
				
				if (parse_seq(rule, seq, prev_parts, tree_name, rtree, grammar))
					return true
			}
			else if (parse_rule(rule.next, prev_parts, tree_name, rtree, grammar))
				return true
		}
		else if (rule.optional)
		{
			if (parse_rule(rule.next, prev_parts, tree_name, rtree, grammar))
				return true
		}
		restore_pos(sp)
		return false
	}
	else if (rule.kind == RK_GROUP)
		go = parse_or(rule.value, t, grammar)
	
	if (go)
	{
		if (rule.sequential)
		{
			var seq = list_tree()
			seq.children.push(t.result)
			
			if (parse_seq(rule, seq, prev_parts, tree_name, rtree, grammar))
				return true
		}
		else if (parse_rule(rule.next, { prev:prev_parts, last:t.result }, tree_name, rtree, grammar))
			return true
	}
	
	if (rule.optional)
	{
		restore_pos(sp)
		
		if (parse_rule(rule.next, { prev:prev_parts, last:undefined }, tree_name, rtree, grammar))
			return true
	}
	restore_pos(sp)
	return false
}

function parse_seq(rule, seq, prev_parts, tree_name, rtree, grammar)
{
	var sp = save_pos()
	
	if (rule.chain_sym == undefined || accept_lit(rule.chain_sym, grammar))
	{
		var go = false
		var t = { result:undefined }
		if (rule.kind == RK_TERM)
			go = parse_term(rule.value, t, grammar)
		else if (rule.kind == RK_NT)
			go = parse_nt(rule.value, t, grammar)
		else if (rule.kind == RK_GROUP)
			go = parse_or(rule.value, t, grammar)
		
		if (go)
		{
			seq.children.push(t.result)
			if (parse_seq(rule, seq, prev_parts, tree_name, rtree, grammar))
				return true
			seq.children.pop()
		}
	}
	
	restore_pos(sp)
	
	if (parse_rule(rule.next, { prev:prev_parts, last:seq }, tree_name, rtree, grammar))
		return true

	restore_pos(sp)

	return false
}

function parse_text(s, grammar)
{
	buffer = s
	pos = 0
	line = 1
	column = 1
	expect_pos = -1
	expect_line_column = "?"
	expects = []
	ch = buffer.length == 0 ? 0 : buffer.charCodeAt(0)
	skip_space()
	cache = []
	for (var i = 0; i < grammar.non_terminals.length + 2; i++)
		cache.push({ pos:-1, success:false, endsp:undefined, result:undefined})
	rtree = { result:undefined }
	if (parse_nt(grammar.find_nt("root"), rtree, grammar) && ch == 0)
		return rtree.result
	return false
}

var iparse_grammar = make_iparse_grammar()


function print_grammar(grammar)
{
 var s = ""
 for (var i = 0; i < grammar.non_terminals.length; i++)
 {
	var non_term = grammar.non_terminals[i]
 	s += "nt " + non_term.name + "\n"
 	for (var j = 0; j < non_term.normal.length; j++)
 	{
 		s += " normal: " + (non_term.normal[j].rule != undefined ? non_term.normal[j].rule.print() : "") + "[" + non_term.normal[j].tree_name + "]\n"
 	}
 	for (var j = 0; j < non_term.recursive.length; j++)
 	{
 		s += " recursive: " + (non_term.recursive[j].rule != undefined ? non_term.recursive[j].rule.print() : "") + "[" + non_term.recursive[j].tree_name + "]\n"
 	}
 }
 for (var i = 0; i < grammar.keywords.length; i++)
 	s += "keyword " + grammar.keywords[i] + "\n"
 return s
}

var the_grammar

function parse_grammar_input()
{
 the_grammar = undefined
 document.P.output.value=""

 grammar = document.P.grammar.value;
 input_pos=0;

 var grammar_tree = parse_text(document.P.grammar.value, iparse_grammar)
 if (grammar_tree == false)
 {
 	document.P.grammar_error.value = report_expecting()
 	document.P.output.value = "(grammar has errors)"
 	d3Tree({ name:"<Grammar has errors>" })
 	return
 }

 //document.P.grammar_error.value = "OK\n"+rtree.result.print()
 var input_grammar = make_grammar(grammar_tree)
 var s = ""
 var s2 = ""
 var found_root = false
 for (var i = 0; i < input_grammar.non_terminals.length; i++)
 	if (input_grammar.non_terminals[i].name == "root")
 	{
 		found_root = true
 		break
 	}
 if (!found_root)
 	s += "Error: There is no 'root' non-terminal\n"
 for (var i = 0; i < input_grammar.non_terminals.length; i++)
 {
 	var nt = input_grammar.non_terminals[i]
 	//s += nt.name + ": " + nt.normal.length + "\n"
 	if (nt.normal.length == 0)
 	{
 		s += "Error: Non-terminal '"+nt.name+"'"
 		if (nt.used_in.length > 0)
 		{
 			s += " (used in"
 			for (var j = 0; j < nt.used_in.length; j++)
 			{
 				if (j > 0)
 					s += ", "
 				s += "'"+nt.used_in[j].name+"'"
 			}
 			s += ")"
 		}
 		s += " has no normal rules\n"
 	}
 }
 for (var i = 0; i < input_grammar.non_terminals.length; i++)
 {
	var nt = input_grammar.non_terminals[i]
 	//s2 += nt.name + ": Used in"
 	//for (var j = 0; j < nt.used_in.length; j++)
 	//	s2 += " "+nt.used_in[j].name
 	//s2 += "\n"
 	if (nt.name != "root")
 	{
 		if (nt.used_in.length == 0)
 			s2 += "Warning: Non-terminal '"+nt.name+"' is not used in other rule\n"
 		else if (nt.used_in.length == 1 && nt.used_in[0] == nt)
 			s2 += "Warning: Non-terminal '"+nt.name+"' is only used in itself\n"
	}
 }
 if (s != "")
 {
 	document.P.grammar_error.value = s + s2
 	document.P.output.value = "(grammar has errors)"
 	return
 }
 document.P.grammar_error.value = s2 + print_grammar(input_grammar)
 the_grammar = input_grammar
 parse_input()
}

var input_tree = undefined

function countAtMost100(t)
{
	var nr = 1
	if (t != undefined && t.children != undefined)
		for (var i = 0; i < t.children.length; i++)
		{
			nr += countAtMost100(t.children[i])
			if (nr >= 100)
				break;
		}
	return nr;
}

function parse_input()
{
	if (the_grammar == undefined)
	{
		document.P.output.value = "(grammar has errors)"
		d3Tree({ name:"<Grammar has errors>" })
		showTree()
		return
	}
	input_tree = parse_text(document.P.input.value, the_grammar)
	if (input_tree == false)
	{
		document.P.output.value = report_expecting()
		d3Tree({ name:"<input has errors>" })
		return
	}
	document.P.output.value = input_tree != undefined ? input_tree.print() : ""
	if (input_tree == undefined || countAtMost100(input_tree) <= 100)
		showTree()
	else
		d3Tree({ name:"<click 'show tree'>" })
}


function spaces(i)
{var r="";
 while(i>0){i-=1;r+=" ";}
 return r;
}

function printx(v)
{
	var s = "(name:"+v.name+",["
	if (v.children == undefined)
		s += "undefined"
	for (var i = 0; i < v.children.length; i++)
	{
		if (i > 0)
			s += ","
		s += printx(v.children[i])
	}
	return s + "]"
}
function showTree()
{
	//document.P.output.value = printx(input_tree.transf())
	d3Tree(input_tree == undefined ? { name:"<NULL>" } : input_tree == false ? { name:"<input has errors>" } : input_tree.transf() )
}

function eval_ast()
{
	var vars = []
	var gresult = ""
	var error_msg = undefined
	var eval = function(ast)
	{
		if (ast == undefined) return undefined
		if (ast.type == "int" || ast.type == "double" || ast.type == "string" || ast.type == "char") return ast.value
		if (ast.type == "ident")
		{
			for (var i = 0; i < vars.length; i++)
				if (vars[i].name == ast.value)
					return vars[i].value
			return undefined
		}
		if (ast.children == undefined) return undefined
		if (ast.type == "list")
		{
			var s = 0
			for (var i = 0; i < ast.children.length; i++)
				s = eval(ast.children[i])
			return s
		}
		if (ast.type == "tree")
		{
			if (ast.name == "add") return ast.children.length == 2 ? eval(ast.children[0]) + eval(ast.children[1]) : undefined
			if (ast.name == "sub") return ast.children.length == 2 ? eval(ast.children[0]) - eval(ast.children[1]) : undefined
			if (ast.name == "times") return ast.children.length == 2 ? eval(ast.children[0]) * eval(ast.children[1]) : undefined
			if (ast.name == "div") return ast.children.length == 2 ? eval(ast.children[0]) / eval(ast.children[1]) : undefined
			if (ast.name == "mod") return ast.children.length == 2 ? eval(ast.children[0]) % eval(ast.children[1]) : undefined
			if (ast.name == "sum")
			{
				var childs = (ast.children.length == 1 && ast.children[0] != undefined && ast.children[0].type == "list") ? ast.children[0].children : ast.children
				var s = 0
				for (var i = 0; i < childs.length; i++)
					s += eval(childs[i])
				return s
			}
			if (ast.name == "multiply")
			{
				var childs = (ast.children.length == 1 && ast.children[0] != undefined && ast.children[0].type == "list") ? ast.children[0].children : ast.children
				var s = 1
				for (var i = 0; i < childs.length; i++)
					s *= eval(childs[i])
				return s
			}
			if (ast.name == "min") return ast.children.length == 1 ? -eval(ast.children[0]) : undefined
			if (ast.name == "le") return ast.children.length == 2 ? eval(ast.children[0]) < eval(ast.children[1]) : undefined
			if (ast.name == "lt") return ast.children.length == 2 ? eval(ast.children[0]) <= eval(ast.children[1]) : undefined
			if (ast.name == "ge") return ast.children.length == 2 ? eval(ast.children[0]) > eval(ast.children[1]) : undefined
			if (ast.name == "gt") return ast.children.length == 2 ? eval(ast.children[0]) >= eval(ast.children[1]) : undefined
			if (ast.name == "eq") return ast.children.length == 2 ? eval(ast.children[0]) == eval(ast.children[1]) : undefined
			if (ast.name == "ne") return ast.children.length == 2 ? eval(ast.children[0]) != eval(ast.children[1]) : undefined
			if (ast.name == "and") return ast.children.length == 2 ? eval(ast.children[0]) && eval(ast.children[1]) : undefined
			if (ast.name == "or") return ast.children.length == 2 ? eval(ast.children[0]) || eval(ast.children[1]) : undefined
			if (ast.name == "not") return ast.children.length == 1 ? !eval(ast.children[0]) : undefined
			if (ast.name == "ass")
			{
				if (ast.children.length != 2) return undefined
				if (ast.children[0].type != "ident") return undefined
				var n = ast.children[0].value
				var v = eval(ast.children[1])
				for (var i = 0; i < vars.length; i++)
					if (vars[i].name == n)
					{
						vars[i].value = v
						return v
					}
				vars.push({ name:n, value:v })
				return v
			}
			if (ast.name == "assto")
			{
				if (ast.children.length != 2) return undefined
				if (ast.children[1].type != "ident") return undefined
				var n = ast.children[1].value
				var v = eval(ast.children[0])
				for (var i = 0; i < vars.length; i++)
					if (vars[i].name == n)
					{
						vars[i].value = v
						return v
					}
				vars.push({ name:n, value:v })
				return v
			}
			if (ast.name == "print")
			{
				if (ast.children.length != 1) return undefined
				var v = eval(ast.children[0])
				gresult += v + "\n"
				return v
			}
			if (ast.name == "prompt")
			{
				if (ast.children.length != 1) return undefined
				var msg = eval(ast.children[0])
				var v = prompt(msg)
				if (/^[-+]?(\d+|Infinity)$/.test(v)) v = Number(v)
				return v
			}
			if (ast.name == "ifthenelse")
			{
				if (ast.children.length != 3) return undefined
				return eval(ast.children[0]) == true ? eval(ast.children[1]) : eval(ast.children[2])
			}
			if (ast.name == "whenotherwise")
			{
				if (ast.children.length != 3) return undefined
				return eval(ast.children[1]) == true ? eval(ast.children[0]) : eval(ast.children[2])
			}
			if (ast.name == "while")
			{
				if (ast.children.length != 2) return undefined
				var s = undefined
				while (eval(ast.children[0]) == true)
					s = eval(ast.children[1])
				return s
			}
			if (ast.name == "defaultsto")
			{
				if (ast.children.length != 2) return undefined
				var v = eval(ast.children[0])
				return v != undefined ? v : eval(ast.children[1])
			}
		}
		return undefined
	}
	var result = eval(input_tree)
	if (error_msg != undefined)
		document.P.output.value = error_msg
	else
		document.P.output.value = (gresult == "") ? result : gresult
}
// -->
</SCRIPT>

<TITLE>Online interactive parser</TITLE>
</HEAD><BODY>

<NOSCRIPT>
<FONT COLOR="#FF0000">
This page requires <B>JavaScript</B> to be enabled.
</FONT>
</NOSCRIPT>

<H1>Online interactive parser</H1>

This page gives <A HREF="#iparser">an interactive parser</A>, which allows you
to enter a grammar and use it to parse some input. It can be a helpful tool in
developping a grammar and testing it agains example input. The parser is a
reimplementation of (a subset of) <A HREF="https://github.com/FransFaase/IParse"
>IParse</A>, an interpretting parser, in JavaScript and responds to keystrokes,
which gives immediate response to the grammar and input being entered. The
abstract syntax tree is displayed as a tree. For demonstration purposes, an
<A HREF="#eval">evaluator</A> for a limited set of language constructs has
been added, such that expression represented by the abstract syntax tree can
be evaluated and some basic control flow statement can be executed. 
<P>
This was created for <A HREF="https://fransfaase.github.io/ParserWorkshop/"
>an online workshop</A> on parsing which was held on
<SCRIPT><!--
document.write(new Date("2021-03-20T13:00:00.000Z").toString())
//--></SCRIPT> and was <A HREF="https://fransfaase.github.io/ParserWorkshop/"
>recorded</A>.
<P>
The source code can be found <A HREF="https://github.com/FransFaase/ParserWorkshop"
>here</A>.
The code for showing the syntax tree is based on <A HREF="http://christos-c.com/treeviewer/"
>Syntactic Tree Viewer</A> by <A HREF="http://christos-c.com/">Christos
Christodoulopoulos</A>, which makes use of <A HREF="https://d3js.org/"
>d3.js</A> and itself is inspired by <A HREF="https://gist.github.com/robschmuecker/7880033"
>D3.js Drag and Drop Zoomable Tree</A> by <A HREF="https://gist.github.com/robschmuecker"
>Rob Schmuecker</A>.
A simular approacht, with a more advanced editor (with syntax-colour) is
	<A HREF="https://info.itemis.com/demo/agl/editor">AGL Editor Demo</A>.

<H2><A NAME="grammar">Grammar description</A></H2>

To parse input that consists of an integer, an identifier and a string, the
following grammar can be used:
<PRE>
root : int ident string .
</PRE>
This grammar consists of one production rule. The production rule starts with
the <TT>root</TT> non-terminal, which is the non-terminal that is used to parse
the whole input. After the colon the elements of the production rule are given.
The element can be terminals and non-terminals. In this case it consists of three
terminals. At the end of the production rule a period is placed. There are
four predefined terminals defined:
<UL>
<LI><TT>int</TT>: parses a whole number
<LI><TT>ident</TT>: parses a identifier, starting with an alphabetic character
	or an underscore followed by zero or more alphabetic characts, underscores
	or numerical characters.
<LI><TT>string</TT>: parses a string surrounded with double quotes.
	The back-slash character acts as an escape character.
<LI><TT>char</TT>: parses a character surrounded with single quotes.
	The back-slash character acts as an escape character.
</UL>
An example input that should parse correctly is:
<PRE>
123 abc "test ?*"
</PRE>
The <A HREF="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract
syntax tree</A> of the parsing is printed as:
<PRE>
(int:123,ident:abc,string:"test ?*")
</PRE>
<P>
The following grammar parses the same input as the above, but now it uses
two extra non-terminal and two additional production rule for those
non-terminals:
<PRE>
root : first rest .
first : int .
rest : ident string .
</PRE>
<P>
But this does affect the abstract syntax tree, which now will look like:
<PRE>
(int:123,(ident:abc,string:"test ?*"))
</PRE>
<P>
To parse input that consists of the keyword <TT>if</TT> followed by an
identifier between round brackets, the following grammar can be used:
<PRE>
root : "if" "(" ident ")" .
</PRE>
In this grammar rule, literal strings, between double quotes are used as
additional terminals in the grammar. Literal strings that start with an
alphabetic character are treated as keywords, meaning that it should be
terminated with a non-identifier character. It also means that it is excluded
as a valid identifier. An example of input that should parse correctly is:
<PRE>
if ( a )
</PRE>
The following input is not parsed correctly, because although it starts with
<TT>if</TT> it does not start with an identifier that is equal to <TT>if</TT>.
<PRE>
iff ( a )
</PRE>
The following input does not parse correctly, because <TT>if</TT> is no longer
a valid identifier:
<PRE>
if ( if )
</PRE>
<P>
To parse input that consists an optional integer, one or more identifiers, and
zero or more strings, the following grammar can be used:
<PRE>
root : int OPT 
       ident SEQ
       string SEQ OPT .
</PRE>
The <TT>OPT</TT> placed after an element indicates that the elements is
optional. The <TT>SEQ</TT> placed after an element indicates that the element
can occur one or more times. The combination of <TT>SEQ</TT> and <TT>OPT</TT>
indicates that the element can occur zero or more times.
<P>
To parse input that consists of a sum of integers, the following grammar can
be used:
<PRE>
root : int CHAIN "+"
</PRE>
The <TT>CHAIN</TT> followed by a literal indicates a chain sequence, where the
literal is used as a separator between the elements. An example input is:
<PRE>
1 + 6 + 5
</PRE>
The <TT>LIST</TT> is a shorthand for a chain sequence with a comma.
<P>
To parse input that consists of intermixed list of integers and identifiers
(separated by commas), the following grammar can be used:
<PRE>
root : ( int | ident ) LIST .
</PRE>
This will parse an input like:
<PRE>
ad, 4, 5, gh, jk
</PRE>
The grammar rule above also shows the use of brackets to group elements and the
vertical bar character to separate alternatives. The vertical bar can also
be used to combine several production rules for one non-terminal together.
<P>
When the input parses correctly, an abstract syntax tree is displayed in the
text area to the right of the input in textual form and as a tree in the area
below it. To annotate this abstract syntax tree, it
is possible to annotate the production rules with identifiers between square
brackets. An example of this is given in the grammar below, a grammar for
simple expressions to add, multiply, and divide numbers:
<PRE>
root : E .
E : F CHAIN "+" [sum].
F : T | F "*" T [times] | F "/" T [div].
T : int | "(" E ")".
</PRE>
<P>
Whitespace is accepted between all the terminals. As whitespace the space,
the tab and the newline characters are accepted and also the two types of
comments that are allowed in the C-language: Any text between <TT>/*</TT> and
<TT>*/</TT> and the remainder of the line followed by a <TT>//</TT> sequence.
<P>
For educational purposes, the rules with respect to the specification of
terminals are limited. For more options, see the C++ implementation of
<A HREF="https://github.com/FransFaase/IParse">IParse</A> and the C
implementation of <A HREF="https://github.com/FransFaase/RawParser"
>RawParser</A>.

<H2><A NAME="iparser">Interactive parser</A></H2>

Below you can enter a grammar and some input to be parsed according to the
grammar. On the left are the input text areas. At every keystroke (or clicking
the execute button) the grammar will be parsed and if it is without errors,
the input below is parsed according to the given grammar. Errors and results
are shown in the text areas on the right. If the abstract syntax tree gets
large, the button 'show tree' needs to be clicked to show it. The button
'evaluate' will acitvate the evaluator described <A HREF="#eval">below</A>.
<P>
<FORM NAME="P">
Enter the grammar:<BR>
<TEXTAREA NAME="grammar" ROWS="20" COLS="80" onkeyup="parse_grammar_input()"></TEXTAREA>
<TEXTAREA NAME="grammar_error" ROWS="20" COLS="80"></TEXTAREA>
<P>
The input to be parsed by the grammar:<BR>
<TEXTAREA NAME="input" ROWS="20" COLS="80" onkeyup="parse_input()"></TEXTAREA>
<TEXTAREA NAME="output" ROWS="20" COLS="80"></TEXTAREA>
<P>
<INPUT TYPE="button" VALUE="execute" ONCLICK="parse_grammar_input()">
<INPUT TYPE="button" VALUE="show tree" ONCLICK="return showTree();">
<INPUT TYPE="button" VALUE="evaluate" ONCLICK="eval_ast()">
<P>
<DIV ID="tree-container" STYLE="width: auto; height: 500px"></DIV>
<SCRIPT>
<!--
parse_grammar_input()
//-->
</SCRIPT>
<P>
<H3><A NAME="eval">Abstract syntax tree evaluator</A></H3>

When the 'evaluate' button is clicked, the abstract syntax tree is evaluated
according to the annotations of the nodes and the basic values. Below the
supported annotations are mentioned and their function is explained:
<UL>
<LI><TT>add</TT>: Add the values of the two child nodes.
<LI><TT>sub</TT>: Substract the values of the two child nodes.
<LI><TT>times</TT>: Multiplies the values of the two child nodes.
<LI><TT>div</TT>: Divides the values of the two child nodes.
<LI><TT>min</TT>: Minus the value of the one child node.
<LI><TT>mod</TT>: Modulo of the value of the two child nodes.
<LI><TT>sum</TT>: Sums the values of the child nodes.
<LI><TT>multiply</TT>: Multiplies the values of the child nodes.
<LI><TT>lt</TT>: True if the value of the left node is smaller than the value of the right value.
<LI><TT>le</TT>: True if the value of the left node is smaller or equal than the value of the right value.
<LI><TT>gt</TT>: True if the value of the left node is greater than the value of the right value.
<LI><TT>ge</TT>: True if the value of the left node is greater or equal than the value of the right value.
<LI><TT>eq</TT>: True if the value of the left node is equal to the value of the right value.
<LI><TT>ne</TT>: True if the value of the left node is not equal to the value of the right value.
<LI><TT>and</TT>: True if the values of the two child nodes are true.
<LI><TT>or</TT>: True if at least on of the values of the two child nodes is true.
<LI><TT>not</TT>: True if the value of the one child node is not true.
<LI><TT>ass</TT>: Assigns the value of the second node to the variable named by the first node.
<LI><TT>assto</TT>: Assigns the value of the first node to the variable named by the second node.
<LI><TT>ifthenelse</TT>: If the value of the first node is true, the second node is evaluated, otherwise the third
<LI><TT>whenotherwise</TT>: If the value of the second node is true, the first node is evaluated, otherwise the third.
<LI><TT>while</TT>: While the value of the first nodes evaluates to true, the second node is evaluated.
<LI><TT>print</TT>: Prints the value of the only child node on a new line.
<LI><TT>prompt</TT>: Prompts the user for a value displaying the text value of the only child node. 
<LI><TT>LIST</TT>: Evaluates the child nodes and returns the value of the last node.
<LI><TT>defaultsto</TT>: Returns the value of the first node, unless it is undefined, then the value of the second node is returned.
</UL>
The result of the evaluation (and the result of print statements) is displayed in the output text area.
<P>
An example grammar using the above annotations is:
<PRE>
root : statement SEQ OPT .
statement
	: ident "=" expr ";" [ass]
	| "if" expr "then" statement SEQ OPT "else" statement SEQ OPT "fi" [ifthenelse]
	| "while" expr "do" statement SEQ OPT "od" [while]
	| "print" expr ";" [print]
	| expr ";"
	.
	
primary_expr
        : ident
        | int
        | char
        | string
        | "(" expr ")"
        .

unary_expr
        : "!" primary_expr [not]
        | "-" primary_expr [min]
        | primary_expr
        .

l_expr1 : l_expr1 "*" unary_expr  [times]
        | l_expr1 "/" unary_expr  [div]
        | l_expr1 "%" unary_expr  [mod]
        | unary_expr
        .
l_expr2 : l_expr2 "+" l_expr1  [add]
        | l_expr2 "-" l_expr1  [sub]
        | l_expr1 
        .
l_expr3 : l_expr3 "&lt;=" l_expr2  [le]
        | l_expr3 "&gt;=" l_expr2  [ge]
        | l_expr3 "&lt;"  l_expr2  [lt]
        | l_expr3 "&gt;"  l_expr2  [gt]
        | l_expr3 "==" l_expr2  [eq]
        | l_expr3 "!=" l_expr2  [ne]
        | l_expr2
        .
l_expr4 : l_expr4 "&amp;&amp;" l_expr3 [land]  | l_expr3 .
l_expr5 : l_expr5 "||" l_expr4 [lor] | l_expr4 .

expr
        : l_expr5 "?" l_expr5 ":" expr  [ifthenelse]
        | l_expr5
        .	
</PRE>
An example program in this language, for calculating the <A HREF="https://en.wikipedia.org/wiki/Greatest_common_divisor"
>greatest common divisor</A> of 345 and 555, is:
<PRE>
a = 345;
b = 555;
while b != 0
do
   c = a % b;
   a = b;
   b = c;
od
print a;
</PRE>
<HR>
Author: <a href="https://www.iwriteiam.nl/Frans.html">Frans</a><br>
<a href="https://www.iwriteiam.nl/">Personal website</a><br>
<a href="https://www.iwriteiam.nl/index.html#email">email address</a>
</BODY></HTML>
